<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `redis` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, redis">

    <title>redis - Rust</title>

    <link rel="stylesheet" type="text/css" href="../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        
        <p class='location'></p>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press 'S' to search, '?' for more options..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Crate <a class='mod' href=''>redis</a><wbr><a class='stability Experimental' title=''>Experimental</a></span><span class='out-of-band'><a href='stability.html'>[stability]</a> <span id='render-detail'>
            <a id="collapse-all" href="#">[-]
            </a>&nbsp;<a id="expand-all" href="#">[+]</a>
        </span><a id='src-0' href='../src/redis/Users/mitsuhiko/Development/redis-rs/src/lib.rs.html#1-330'>[src]</a></span></h1>
<div class='docblock'><p>redis-rs is a rust implementation of a Redis client library.  It exposes
a general purpose interface to Redis and also provides specific helpers for
commonly used functionality.</p>

<p>The crate is called <code>redis</code> and you can depend on it via cargo:</p>

<pre><code class="language-ini">[dependencies.redis-rs]
git = &quot;https://github.com/mitsuhiko/redis-rs.git&quot;
</code></pre>

<h1 id="basic-operation" class='section-header'><a
                           href="#basic-operation">Basic Operation</a></h1>
<p>redis-rs exposes to API levels: a low- and a high-level part.  The high-level
part does not expose all the functionality of redis and might take some
liberties in how it speaks the protocol.  The low-level part of the API
allows you to express any request on the redis level.  You can fluently
switch between both API levels at any point.</p>

<h2 id="connection-handling" class='section-header'><a
                           href="#connection-handling">Connection Handling</a></h2>
<p>For connecting to redis you can use a client object which then can produce
actual connections.  Connections and clients as well as results of
connections and clients are considered <code>ConnectionLike</code> objects and
can be used anywhere a request is made.</p>

<p>The full canonical way to get a connection is to create a client and
to ask for a connection from it:</p>
<pre class='rust '>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>redis</span>;

<span class='kw'>fn</span> <span class='ident'>do_something</span>() <span class='op'>-&gt;</span> <span class='ident'>redis</span>::<span class='ident'>RedisResult</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='ident'>client</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>redis</span>::<span class='ident'>Client</span>::<span class='ident'>open</span>(<span class='string'>&quot;redis://127.0.0.1/&quot;</span>));
    <span class='kw'>let</span> <span class='ident'>con</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>client</span>.<span class='ident'>get_connection</span>());

    <span class='comment'>/* do something here */</span>

    <span class='prelude-val'>Ok</span>(())
}
</pre>

<h2 id="connection-parameters" class='section-header'><a
                           href="#connection-parameters">Connection Parameters</a></h2>
<p>redis-rs knows different ways to define where a connection should
go.  The parameter to <code>Client::open</code> needs to implement the
<code>IntoConnectionInfo</code> trait of which there are three implementations:</p>

<ul>
<li>string slices in <code>redis://</code> URL format.</li>
<li>URL objects from the redis-url crate.</li>
<li><code>ConnectionInfo</code> objects.</li>
</ul>

<p>The URL format is <code>redis://[:&lt;passwd&gt;@]&lt;hostname&gt;[:port][/&lt;db&gt;]</code></p>

<h2 id="executing-low-level-commands" class='section-header'><a
                           href="#executing-low-level-commands">Executing Low-Level Commands</a></h2>
<p>To execute low-level commands you can use the <code>cmd</code> function which allows
you to build redis requests.  Once you have configured a command object
to your liking you can send a query into any <code>ConnectionLike</code> object:</p>
<pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>do_something</span>(<span class='ident'>con</span>: <span class='kw-2'>&amp;</span><span class='ident'>redis</span>::<span class='ident'>Connection</span>) <span class='op'>-&gt;</span> <span class='ident'>redis</span>::<span class='ident'>RedisResult</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
    <span class='kw'>let</span> _ : () <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>redis</span>::<span class='ident'>cmd</span>(<span class='string'>&quot;SET&quot;</span>).<span class='ident'>arg</span>(<span class='string'>&quot;my_key&quot;</span>).<span class='ident'>arg</span>(<span class='number'>42i</span>).<span class='ident'>query</span>(<span class='ident'>con</span>));
    <span class='prelude-val'>Ok</span>(())
}
</pre>

<p>Upon querying the return value is a result object.  If you do not care
about the actual return value (other than that it is not a failure)
you can always type annotate it to the unit type <code>()</code>.</p>

<h2 id="executing-high-level-commands" class='section-header'><a
                           href="#executing-high-level-commands">Executing High-Level Commands</a></h2>
<p>The high-level interface is similar.  For it to become available you
need to use the <code>Commands</code> trait in which case all <code>ConnectionLike</code>
objects the library provides will also have high-level methods which
make working with the protocol easier:</p>
<pre class='rust '>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>redis</span>;
<span class='kw'>use</span> <span class='ident'>redis</span>::<span class='ident'>Commands</span>;

<span class='kw'>fn</span> <span class='ident'>do_something</span>(<span class='ident'>con</span>: <span class='kw-2'>&amp;</span><span class='ident'>redis</span>::<span class='ident'>Connection</span>) <span class='op'>-&gt;</span> <span class='ident'>redis</span>::<span class='ident'>RedisResult</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span> {
    <span class='kw'>let</span> _ : () <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>con</span>.<span class='ident'>set</span>(<span class='string'>&quot;my_key&quot;</span>, <span class='number'>42i</span>));
    <span class='prelude-val'>Ok</span>(())
}
</pre>

<p>Note that high-level commands are work in progress and many are still
missing!</p>

<h2 id="type-conversions" class='section-header'><a
                           href="#type-conversions">Type Conversions</a></h2>
<p>Because redis inherently is mostly type-less and the protocol is not
exactly friendly to developers, this library provides flexible support
for casting values to the intended results.  This is driven through the
<code>FromRedisValue</code> and <code>ToRedisArgs</code> traits.</p>

<p>The <code>arg</code> method of the command will accept a wide range of types through
the <code>ToRedisArgs</code> trait and the <code>query</code> method of a command can convert the
value to what you expect the function to return through the <code>FromRedisValue</code>
trait.  This is quite flexible and allows vectors, tuples, hashsets, hashmaps
as well as optional values:</p>
<pre class='rust '>
<span class='kw'>let</span> <span class='ident'>count</span> : <span class='ident'>i32</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>con</span>.<span class='ident'>get</span>(<span class='string'>&quot;my_counter&quot;</span>));
<span class='kw'>let</span> <span class='ident'>count</span> <span class='op'>=</span> <span class='ident'>con</span>.<span class='ident'>get</span>(<span class='string'>&quot;my_counter&quot;</span>).<span class='ident'>unwrap_or</span>(<span class='number'>0i32</span>);
<span class='kw'>let</span> <span class='ident'>k</span> : <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>String</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>con</span>.<span class='ident'>get</span>(<span class='string'>&quot;missing_key&quot;</span>));
<span class='kw'>let</span> <span class='ident'>name</span> : <span class='ident'>String</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>con</span>.<span class='ident'>get</span>(<span class='string'>&quot;my_name&quot;</span>));
<span class='kw'>let</span> <span class='ident'>bin</span> : <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>con</span>.<span class='ident'>get</span>(<span class='string'>&quot;my_binary&quot;</span>));
<span class='kw'>let</span> <span class='ident'>map</span> : <span class='ident'>HashMap</span><span class='op'>&lt;</span><span class='ident'>String</span>, <span class='ident'>i32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>con</span>.<span class='ident'>hgetall</span>(<span class='string'>&quot;my_hash&quot;</span>));
<span class='kw'>let</span> <span class='ident'>keys</span> : <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>String</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>con</span>.<span class='ident'>hkeys</span>(<span class='string'>&quot;my_hash&quot;</span>));
<span class='kw'>let</span> <span class='ident'>mems</span> : <span class='ident'>HashSet</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>con</span>.<span class='ident'>smembers</span>(<span class='string'>&quot;my_set&quot;</span>));
<span class='kw'>let</span> (<span class='ident'>k1</span>, <span class='ident'>k2</span>) : (<span class='ident'>String</span>, <span class='ident'>String</span>) <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>con</span>.<span class='ident'>get</span>([<span class='string'>&quot;k1&quot;</span>, <span class='string'>&quot;k2&quot;</span>].<span class='ident'>as_slice</span>()));
</pre>

<h1 id="iteration-protocol" class='section-header'><a
                           href="#iteration-protocol">Iteration Protocol</a></h1>
<p>In addition to sending a single query you iterators are also supported.  When
used with regular bulk responses they don&#39;t give you much over querying and
converting into a vector (both use a vector internally) but they can also
be used with <code>SCAN</code> like commands in which case iteration will send more
queries until the cursor is exhausted:</p>
<pre class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>iter</span> : <span class='ident'>redis</span>::<span class='ident'>Iter</span><span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>redis</span>::<span class='ident'>cmd</span>(<span class='string'>&quot;SSCAN&quot;</span>).<span class='ident'>arg</span>(<span class='string'>&quot;my_set&quot;</span>)
    .<span class='ident'>cursor_arg</span>(<span class='number'>0</span>).<span class='ident'>iter</span>(<span class='kw-2'>&amp;</span><span class='ident'>con</span>));
<span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='ident'>iter</span> {
    <span class='comment'>// do something with the item</span>
}
</pre>

<p>As you can see the cursor argument needs to be defined with <code>cursor_arg</code>
instead of <code>arg</code> so that the library knows which argument needs updating
as the query is run for more items.</p>

<h1 id="pipelining" class='section-header'><a
                           href="#pipelining">Pipelining</a></h1>
<p>In addition to simple queries you can also send command pipelines.  This
is provided through the <code>pipe</code> function.  It works very similar to sending
individual commands but you can send more than one in one go.  This also
allows you to ignore individual results so that matching on the end result
is easier:</p>
<pre class='rust '>
<span class='kw'>let</span> (<span class='ident'>k1</span>, <span class='ident'>k2</span>) : (<span class='ident'>i32</span>, <span class='ident'>i32</span>) <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>redis</span>::<span class='ident'>pipe</span>()
    .<span class='ident'>cmd</span>(<span class='string'>&quot;SET&quot;</span>).<span class='ident'>arg</span>(<span class='string'>&quot;key_1&quot;</span>).<span class='ident'>arg</span>(<span class='number'>42i</span>).<span class='ident'>ignore</span>()
    .<span class='ident'>cmd</span>(<span class='string'>&quot;SET&quot;</span>).<span class='ident'>arg</span>(<span class='string'>&quot;key_2&quot;</span>).<span class='ident'>arg</span>(<span class='number'>43i</span>).<span class='ident'>ignore</span>()
    .<span class='ident'>cmd</span>(<span class='string'>&quot;GET&quot;</span>).<span class='ident'>arg</span>(<span class='string'>&quot;key_1&quot;</span>)
    .<span class='ident'>cmd</span>(<span class='string'>&quot;GET&quot;</span>).<span class='ident'>arg</span>(<span class='string'>&quot;key_2&quot;</span>).<span class='ident'>query</span>(<span class='kw-2'>&amp;</span><span class='ident'>con</span>));
</pre>

<p>If you want the pipeline to be wrapped in a <code>MULTI</code>/<code>EXEC</code> block you can
easily do that by switching the pipeline into <code>atomic</code> mode.  From the
caller&#39;s point of view nothing changes, the pipeline itself will take
care of the rest for you:</p>
<pre class='rust '>
<span class='kw'>let</span> (<span class='ident'>k1</span>, <span class='ident'>k2</span>) : (<span class='ident'>i32</span>, <span class='ident'>i32</span>) <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>redis</span>::<span class='ident'>pipe</span>()
    .<span class='ident'>atomic</span>()
    .<span class='ident'>cmd</span>(<span class='string'>&quot;SET&quot;</span>).<span class='ident'>arg</span>(<span class='string'>&quot;key_1&quot;</span>).<span class='ident'>arg</span>(<span class='number'>42i</span>).<span class='ident'>ignore</span>()
    .<span class='ident'>cmd</span>(<span class='string'>&quot;SET&quot;</span>).<span class='ident'>arg</span>(<span class='string'>&quot;key_2&quot;</span>).<span class='ident'>arg</span>(<span class='number'>43i</span>).<span class='ident'>ignore</span>()
    .<span class='ident'>cmd</span>(<span class='string'>&quot;GET&quot;</span>).<span class='ident'>arg</span>(<span class='string'>&quot;key_1&quot;</span>)
    .<span class='ident'>cmd</span>(<span class='string'>&quot;GET&quot;</span>).<span class='ident'>arg</span>(<span class='string'>&quot;key_2&quot;</span>).<span class='ident'>query</span>(<span class='kw-2'>&amp;</span><span class='ident'>con</span>));
</pre>

<p>You can also use high-level commands on pipelines through the
<code>PipelineCommands</code> trait:</p>
<pre class='rust '>
<span class='kw'>use</span> <span class='ident'>redis</span>::<span class='ident'>PipelineCommands</span>;
<span class='kw'>let</span> (<span class='ident'>k1</span>, <span class='ident'>k2</span>) : (<span class='ident'>i32</span>, <span class='ident'>i32</span>) <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>redis</span>::<span class='ident'>pipe</span>()
    .<span class='ident'>atomic</span>()
    .<span class='ident'>set</span>(<span class='string'>&quot;key_1&quot;</span>, <span class='number'>42i</span>).<span class='ident'>ignore</span>()
    .<span class='ident'>set</span>(<span class='string'>&quot;key_2&quot;</span>, <span class='number'>43i</span>).<span class='ident'>ignore</span>()
    .<span class='ident'>get</span>(<span class='string'>&quot;key_1&quot;</span>)
    .<span class='ident'>get</span>(<span class='string'>&quot;key_2&quot;</span>).<span class='ident'>query</span>(<span class='kw-2'>&amp;</span><span class='ident'>con</span>));
</pre>

<h1 id="transactions" class='section-header'><a
                           href="#transactions">Transactions</a></h1>
<p>Transactions are available through atomic pipelines.  In order to use
them in a more simple way you can use the <code>transaction</code> function of a
connection:</p>
<pre class='rust '>
<span class='kw'>use</span> <span class='ident'>redis</span>::{<span class='ident'>Commands</span>, <span class='ident'>PipelineCommands</span>};
<span class='kw'>let</span> <span class='ident'>key</span> <span class='op'>=</span> <span class='string'>&quot;the_key&quot;</span>;
<span class='kw'>let</span> (<span class='ident'>new_val</span>,) : (<span class='ident'>int</span>,) <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>redis</span>::<span class='ident'>transaction</span>(<span class='kw-2'>&amp;</span><span class='ident'>con</span>, [<span class='ident'>key</span>].<span class='ident'>as_slice</span>(), <span class='op'>|</span><span class='ident'>pipe</span><span class='op'>|</span> {
    <span class='kw'>let</span> <span class='ident'>old_val</span> : <span class='ident'>int</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>con</span>.<span class='ident'>get</span>(<span class='ident'>key</span>));
    <span class='ident'>pipe</span>
        .<span class='ident'>set</span>(<span class='ident'>key</span>, <span class='ident'>old_val</span> <span class='op'>+</span> <span class='number'>1</span>).<span class='ident'>ignore</span>()
        .<span class='ident'>get</span>(<span class='ident'>key</span>).<span class='ident'>query</span>(<span class='kw-2'>&amp;</span><span class='ident'>con</span>)
}));
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;The incremented number is: {}&quot;</span>, <span class='ident'>new_val</span>);
</pre>

<p>For more information see the <code>transaction</code> function.</p>

<h1 id="pubsub" class='section-header'><a
                           href="#pubsub">PubSub</a></h1>
<p>Pubsub is currently work in progress but provided through the <code>PubSub</code>
connection object.  Due to the fact that Rust does not have support
for async IO in libnative yet, the API does not provide a way to
read messages with any form of timeout yet.</p>

<p>Example usage:</p>
<pre class='rust '>
<span class='kw'>let</span> <span class='ident'>client</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>redis</span>::<span class='ident'>Client</span>::<span class='ident'>open</span>(<span class='string'>&quot;redis://127.0.0.1/&quot;</span>));
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>pubsub</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>client</span>.<span class='ident'>get_pubsub</span>());
<span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>pubsub</span>.<span class='ident'>subscribe</span>(<span class='string'>&quot;channel_1&quot;</span>));
<span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>pubsub</span>.<span class='ident'>subscribe</span>(<span class='string'>&quot;channel_2&quot;</span>));

<span class='kw'>loop</span> {
    <span class='kw'>let</span> <span class='ident'>msg</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>pubsub</span>.<span class='ident'>get_message</span>());
    <span class='kw'>let</span> <span class='ident'>payload</span> : <span class='ident'>String</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>msg</span>.<span class='ident'>get_payload</span>());
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;channel &#39;{}&#39;: {}&quot;</span>, <span class='ident'>msg</span>.<span class='ident'>get_channel_name</span>(), <span class='ident'>payload</span>);
}
</pre>

<h1 id="scripts" class='section-header'><a
                           href="#scripts">Scripts</a></h1>
<p>Lua scripts are supported through the <code>Script</code> type in a convenient
way (it does not support pipelining currently).  It will automatically
load the script if it does not exist and invoke it.</p>

<p>Example:</p>
<pre class='rust '>
<span class='kw'>let</span> <span class='ident'>script</span> <span class='op'>=</span> <span class='ident'>redis</span>::<span class='ident'>Script</span>::<span class='ident'>new</span>(<span class='string'>r&quot;
    return tonumber(ARGV[1]) + tonumber(ARGV[2]);
&quot;</span>);
<span class='kw'>let</span> <span class='ident'>result</span> : <span class='ident'>int</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>script</span>.<span class='ident'>arg</span>(<span class='number'>1i</span>).<span class='ident'>arg</span>(<span class='number'>2i</span>).<span class='ident'>invoke</span>(<span class='kw-2'>&amp;</span><span class='ident'>con</span>));
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>result</span>, <span class='number'>3</span>);
</pre>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.Client.html'
                               title='redis::Client'>Client</a></td>
                        <td class='docblock short'><p>The client type.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.Cmd.html'
                               title='redis::Cmd'>Cmd</a></td>
                        <td class='docblock short'><p>Represents redis commands.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.Connection.html'
                               title='redis::Connection'>Connection</a></td>
                        <td class='docblock short'><p>Represents a stateful redis TCP connection.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.ConnectionInfo.html'
                               title='redis::ConnectionInfo'>ConnectionInfo</a></td>
                        <td class='docblock short'><p>Holds the connection information that redis should use for connecting.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.InfoDict.html'
                               title='redis::InfoDict'>InfoDict</a></td>
                        <td class='docblock short'><p>An info dictionary type.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.Iter.html'
                               title='redis::Iter'>Iter</a></td>
                        <td class='docblock short'><p>Represents a redis iterator.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.Msg.html'
                               title='redis::Msg'>Msg</a></td>
                        <td class='docblock short'><p>Represents a pubsub message.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.Parser.html'
                               title='redis::Parser'>Parser</a></td>
                        <td class='docblock short'><p>The internal redis response parser.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.Pipeline.html'
                               title='redis::Pipeline'>Pipeline</a></td>
                        <td class='docblock short'><p>Represents a redis command pipeline.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.PubSub.html'
                               title='redis::PubSub'>PubSub</a></td>
                        <td class='docblock short'><p>Represents a pubsub connection.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.RedisError.html'
                               title='redis::RedisError'>RedisError</a></td>
                        <td class='docblock short'><p>Represents a redis error.  For the most part you should be using
the Error trait to interact with this rather than the actual
struct.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.Script.html'
                               title='redis::Script'>Script</a></td>
                        <td class='docblock short'><p>Represents a lua script.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.ScriptInvocation.html'
                               title='redis::ScriptInvocation'>ScriptInvocation</a></td>
                        <td class='docblock short'><p>Represents a prepared script call.</p>
</td>
                    </tr>
                </table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='enum' href='enum.ErrorKind.html'
                               title='redis::ErrorKind'>ErrorKind</a></td>
                        <td class='docblock short'><p>An enum of all error kinds.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='enum' href='enum.NumericBehavior.html'
                               title='redis::NumericBehavior'>NumericBehavior</a></td>
                        <td class='docblock short'><p>Helper enum that is used in some situations to describe
the behavior of arguments in a numeric context.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='enum' href='enum.Value.html'
                               title='redis::Value'>Value</a></td>
                        <td class='docblock short'><p>Internal low-level redis value enum.</p>
</td>
                    </tr>
                </table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='trait' href='trait.Commands.html'
                               title='redis::Commands'>Commands</a></td>
                        <td class='docblock short'><p>Implements common redis commands for connection like objects.  This
allows you to send commands straight to a connection or client.  It
is also implemented for redis results of clients which makes for
very convenient access in some basic cases.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='trait' href='trait.ConnectionLike.html'
                               title='redis::ConnectionLike'>ConnectionLike</a></td>
                        <td class='docblock short'><p>Implements the &quot;stateless&quot; part of the connection interface that is used by the
different objects in redis-rs.  Primarily it obviously applies to <code>Connection</code>
object but also some other objects implement the interface (for instance
whole clients or certain redis results).</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='trait' href='trait.FromRedisValue.html'
                               title='redis::FromRedisValue'>FromRedisValue</a></td>
                        <td class='docblock short'><p>This trait is used to convert a redis value into a more appropriate
type.  While a redis <code>Value</code> can represent any response that comes
back from the redis server, usually you want to map this into something
that works better in rust.  For instance you might want to convert the
return value into a <code>String</code> or an integer.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='trait' href='trait.IntoConnectionInfo.html'
                               title='redis::IntoConnectionInfo'>IntoConnectionInfo</a></td>
                        <td class='docblock short'><p>Converts an object into a connection info struct.  This allows the
constructor of the client to accept connection information in a
range of different formats.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='trait' href='trait.PipelineCommands.html'
                               title='redis::PipelineCommands'>PipelineCommands</a></td>
                        <td class='docblock short'><p>Implements common redis commands for pipelines.  Unlike the regular
commands trait, this returns the pipeline rather than a result
directly.  Other than that it works the same however.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='trait' href='trait.ToRedisArgs.html'
                               title='redis::ToRedisArgs'>ToRedisArgs</a></td>
                        <td class='docblock short'><p>Used to convert a value into one or multiple redis argument
strings.  Most values will produce exactly one item but in
some cases it might make sense to produce more than one.</p>
</td>
                    </tr>
                </table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='fn' href='fn.cmd.html'
                               title='redis::cmd'>cmd</a></td>
                        <td class='docblock short'><p>Shortcut function to creating a command with a single argument.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='fn' href='fn.from_redis_value.html'
                               title='redis::from_redis_value'>from_redis_value</a></td>
                        <td class='docblock short'><p>A shortcut function to invoke <code>FromRedisValue::from_redis_value</code>
to make the API slightly nicer.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='fn' href='fn.pack_command.html'
                               title='redis::pack_command'>pack_command</a></td>
                        <td class='docblock short'><p>Packs a bunch of commands into a request.  This is generally a quite
useless function as this functionality is nicely wrapped through the
<code>Cmd</code> object, but in some cases it can be useful.  The return value
of this can then be send to the low level <code>ConnectionLike</code> methods.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='fn' href='fn.parse_redis_url.html'
                               title='redis::parse_redis_url'>parse_redis_url</a></td>
                        <td class='docblock short'><p>This function takes a redis URL string and parses it into a URL
as used by rust-url.  This is necessary as the default parser does
not understand how redis URLs function.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='fn' href='fn.parse_redis_value.html'
                               title='redis::parse_redis_value'>parse_redis_value</a></td>
                        <td class='docblock short'><p>Parses bytes into a redis value.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='fn' href='fn.pipe.html'
                               title='redis::pipe'>pipe</a></td>
                        <td class='docblock short'><p>Shortcut for creating a new pipeline.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='fn' href='fn.transaction.html'
                               title='redis::transaction'>transaction</a></td>
                        <td class='docblock short'><p>This function simplifies transaction management slightly.  What it
does is automatically watching keys and then going into a transaction
loop util it succeeds.  Once it goes through the results are
returned.</p>
</td>
                    </tr>
                </table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table>
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='type' href='type.RedisResult.html'
                               title='redis::RedisResult'>RedisResult</a></td>
                        <td class='docblock short'><p>Library generic result type.</p>
</td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&larrb;</dt>
                <dd>Move up in search results</dd>
                <dt>&rarrb;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code>, <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "redis";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script async src="../search-index.js"></script>
</body>
</html>